"""Simulate distributed claim persistence and result aggregation.

Usage:
    uv run scripts/distributed_coordination_sim.py --agents 3 --loops 2
"""

from __future__ import annotations

import argparse
import json
import random
import sys
import time
import types
from collections import Counter
from contextlib import suppress
from dataclasses import dataclass
from typing import Any, Iterable, List, Protocol, TypeVar

if "docx" not in sys.modules:
    docx_module = types.ModuleType("docx")
    setattr(docx_module, "Document", lambda *_args, **_kwargs: None)
    sys.modules["docx"] = docx_module

if "pdfminer" not in sys.modules:
    high_level = types.ModuleType("pdfminer.high_level")
    setattr(high_level, "extract_text", lambda *_args, **_kwargs: "")
    pdfminer_module = types.ModuleType("pdfminer")
    setattr(pdfminer_module, "high_level", high_level)
    sys.modules["pdfminer"] = pdfminer_module
    sys.modules["pdfminer.high_level"] = high_level

from autoresearch.distributed.broker import InMemoryBroker
from autoresearch.distributed.coordinator import ResultAggregator, publish_claim

ACTION_RESULT = "agent_result"
ACTION_STOP = "stop"


class _SupportsLessThan(Protocol):
    """Protocol representing values that define an ordering."""

    def __lt__(self, other: Any, /) -> bool:
        """Return ``True`` if ``self`` is less than ``other``."""


IdentifierT = TypeVar("IdentifierT", bound=_SupportsLessThan)
MessageT = TypeVar("MessageT")

__all__ = [
    "SimulationConfig",
    "SimulationSummary",
    "elect_leader",
    "process_messages",
    "run_simulation",
    "parse_args",
    "main",
]


@dataclass
class SimulationConfig:
    """Configuration for the coordination simulation."""

    agents: int
    loops: int
    claims_per_agent: int
    jitter_s: float
    seed: int


@dataclass
class SimulationSummary:
    """Summary statistics generated by the simulation."""

    expected_results: int
    aggregated_results: int
    expected_claims: int
    persisted_claims: int
    duplicate_claims: int
    ordering_ok: bool

    def to_json(self) -> str:
        """Return a formatted JSON representation."""

        return json.dumps(self.__dict__, indent=2, sort_keys=True)


def _claim_key(claim: dict[str, int | str]) -> tuple[int, str, int]:
    """Return a sortable key representing ``claim``."""

    return (
        int(claim["loop"]),
        str(claim["agent"]),
        int(claim["ordinal"]),
    )


def elect_leader(agent_ids: Iterable[IdentifierT]) -> IdentifierT:
    """Return the smallest identifier from ``agent_ids``.

    The election mirrors the proof sketch in
    :mod:`docs.algorithms.distributed_coordination`, scanning each identifier
    exactly once. The chosen identifier therefore belongs to the original set
    and is deterministic regardless of iteration order.

    Args:
        agent_ids: Iterable of comparable identifiers. Must contain at least
            one element.

    Returns:
        The minimum identifier according to the ``<`` relation.

    Raises:
        ValueError: If ``agent_ids`` is empty.
    """

    ids = list(agent_ids)
    if not ids:
        raise ValueError("agent_ids must contain at least one identifier")

    leader = ids[0]
    for candidate in ids[1:]:
        if candidate < leader:
            leader = candidate
    return leader


def process_messages(messages: Iterable[MessageT]) -> list[MessageT]:
    """Return messages in first-in-first-out order.

    The helper replays the broker's FIFO guarantee described in
    :mod:`docs.algorithms.distributed_coordination` by iterating through the
    provided sequence exactly once and returning a new list with the same
    ordering.

    Args:
        messages: Iterable of messages published to the broker.

    Returns:
        A list of messages in the order they were observed.
    """

    return list(messages)


def _simulate_messages(
    cfg: SimulationConfig,
) -> tuple[List[dict], List[dict[str, int | str]], List[dict[str, int | str]]]:
    """Run the simulation and return aggregated results and stored claims."""

    rng = random.Random(cfg.seed)
    result_broker = InMemoryBroker()
    storage_broker = InMemoryBroker()
    aggregator = ResultAggregator(result_broker.queue)
    aggregator.start()
    expected_claims: List[dict[str, int | str]] = []

    try:
        for loop in range(cfg.loops):
            agent_order = list(range(cfg.agents))
            rng.shuffle(agent_order)
            for agent_idx in agent_order:
                agent_name = f"agent-{agent_idx}"
                claims = []
                for ordinal in range(cfg.claims_per_agent):
                    claim: dict[str, int | str] = {
                        "loop": loop,
                        "agent": agent_name,
                        "ordinal": ordinal,
                        "payload": f"{loop}-{agent_idx}-{ordinal}",
                    }
                    publish_claim(storage_broker, claim)
                    expected_claims.append(claim)
                    claims.append(claim)
                message = {
                    "action": ACTION_RESULT,
                    "agent": agent_name,
                    "loop": loop,
                    "result": {"claims": claims},
                    "pid": 0,
                }
                result_broker.publish(message)
                if cfg.jitter_s > 0:
                    time.sleep(rng.uniform(0, cfg.jitter_s))
    finally:
        result_broker.publish({"action": ACTION_STOP})
        aggregator.join()
        aggregated = list(aggregator.results)
        aggregator.results[:] = []
        manager = getattr(aggregator, "_manager", None)
        if manager is not None:
            with suppress(Exception):
                manager.shutdown()
        result_broker.shutdown()

    storage_broker.publish({"action": ACTION_STOP})
    stored_claims: List[dict[str, int | str]] = []
    while True:
        msg = storage_broker.queue.get()
        if msg.get("action") == ACTION_STOP:
            break
        stored_claims.append(msg["claim"])
    storage_broker.shutdown()

    return aggregated, stored_claims, expected_claims


def run_simulation(cfg: SimulationConfig) -> SimulationSummary:
    """Execute the simulation and compute summary statistics."""

    aggregated, stored_claims, expected_claims = _simulate_messages(cfg)
    aggregated_results = len(aggregated)
    expected_results = cfg.agents * cfg.loops
    expected_keys = [_claim_key(c) for c in expected_claims]
    persisted_keys = [_claim_key(c) for c in stored_claims]
    duplicates = sum(count - 1 for count in Counter(persisted_keys).values())
    ordering_ok = expected_keys == persisted_keys

    return SimulationSummary(
        expected_results=expected_results,
        aggregated_results=aggregated_results,
        expected_claims=len(expected_keys),
        persisted_claims=len(persisted_keys),
        duplicate_claims=duplicates,
        ordering_ok=ordering_ok,
    )


def parse_args() -> SimulationConfig:
    """Parse command-line arguments into a configuration object."""

    parser = argparse.ArgumentParser(
        description="Simulate distributed coordination queues",
    )
    parser.add_argument(
        "--agents",
        type=int,
        default=3,
        help="number of agents",
    )
    parser.add_argument("--loops", type=int, default=2, help="number of loops")
    parser.add_argument(
        "--claims",
        type=int,
        default=2,
        help="claims produced per agent per loop",
    )
    parser.add_argument(
        "--jitter",
        type=float,
        default=0.0,
        help="max sleep in seconds to jitter message timing",
    )
    parser.add_argument("--seed", type=int, default=7, help="random seed")
    args = parser.parse_args()
    if args.agents <= 0 or args.loops <= 0 or args.claims <= 0:
        raise SystemExit("agents, loops, and claims must be positive")
    if args.jitter < 0:
        raise SystemExit("jitter must be non-negative")
    return SimulationConfig(
        agents=args.agents,
        loops=args.loops,
        claims_per_agent=args.claims,
        jitter_s=args.jitter,
        seed=args.seed,
    )


def main() -> None:
    """Entry point for the coordination simulation."""

    cfg = parse_args()
    summary = run_simulation(cfg)
    print(summary.to_json())
    if summary.aggregated_results != summary.expected_results:
        raise SystemExit("aggregated results count mismatch")
    if summary.persisted_claims != summary.expected_claims:
        raise SystemExit("claim persistence mismatch")
    if not summary.ordering_ok:
        raise SystemExit("storage claim ordering violated")
    if summary.duplicate_claims:
        raise SystemExit("duplicate claims detected")


if __name__ == "__main__":
    main()
